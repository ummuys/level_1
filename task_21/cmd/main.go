package main

import "fmt"

// Нужный интрейфес
type target interface {
	someFunc()
}

// Конструктор
func newTarget(ae *adaptee) target {
	return &adapter{ae: ae}
}

// Сам адаптер
type adapter struct {
	ae *adaptee
}

func (ar *adapter) someFunc() {
	ar.ae.SayHello()
}

// Несовместный тип интрефейсу
type adaptee struct{}

func (ae *adaptee) SayHello() {
	fmt.Println("Hello!")
}

func main() {
	t := newTarget(&adaptee{})
	t.someFunc()
}

// Как работает:
// 1) Мы создаем структуру-адаптер с такими методами, которые присутствуют в нужном интерфейсе
// 2) В стуктуре-адаптер делаем поле с той структурой, которая несовместима с интерфейсом
// 3) В адаптере храним ссылку на несовместимый тип
// 4) В методах структуре-адаптера вызываем те методы, которые реализованы в несовместимой

// Плюсы:
// 1) Не нужно переписывать существующий код
// 2) Можно унифицировать разные реализации под единый интерфейс.

// Минусы:
// 1) Дополнительный слой абстракции
// 2) Избыточность при очень простых интерфейсах
// 3) Снижение производительности кода при больших объектах или сложных методов

// Где используется:
// 1) Интеграция со сторонними библиотеками с неудобным API
// 2) Тестирование: легко подменять реализации через интерфейс
